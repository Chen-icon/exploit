diff --git a/net/netfilter/nf_tables_api.c b/net/netfilter/nf_tables_api.c
index 121ad5981520..b46fbbd28b53 100644
--- a/net/netfilter/nf_tables_api.c
+++ b/net/netfilter/nf_tables_api.c
@@ -5090,19 +5090,33 @@ static int nft_setelem_parse_data(struct nft_ctx *ctx, struct nft_set *set,
 				  struct nft_data *data,
 				  struct nlattr *attr)
 {
-	u32 dtype;
+	// u32 dtype;
 
-	if (set->dtype == NFT_DATA_VERDICT)
-		dtype = NFT_DATA_VERDICT;
-	else
-		dtype = NFT_DATA_VALUE;
+	// if (set->dtype == NFT_DATA_VERDICT)
+	// 	dtype = NFT_DATA_VERDICT;
+	// else
+	// 	dtype = NFT_DATA_VALUE;
+
+	// desc->type = dtype;
+	// desc->size = NFT_DATA_VALUE_MAXLEN;
+	// desc->len = set->dlen;
+	// desc->flags = NFT_DATA_DESC_SETELEM;
 
-	desc->type = dtype;
+	// return nft_data_init(ctx, data, desc, attr);
+	// up is openeuler, down is for cve
+	int err;
 	desc->size = NFT_DATA_VALUE_MAXLEN;
-	desc->len = set->dlen;
 	desc->flags = NFT_DATA_DESC_SETELEM;
-
-	return nft_data_init(ctx, data, desc, attr);
+ 
+ 	err = nft_data_init(ctx, data, desc, attr);
+ 	if (err < 0)
+ 		return err;
+ 
+	if (desc->type != NFT_DATA_VERDICT && desc->len != set->dlen) {
+ 		nft_data_release(data, desc->type);
+ 		return -EINVAL;
+ 	}
+	return 0;
 }
 
 static int nft_get_set_elem(struct nft_ctx *ctx, struct nft_set *set,
@@ -8983,6 +8997,7 @@ static int nft_verdict_init(const struct nft_ctx *ctx, struct nft_data *data,
 	}
 
 	desc->len = sizeof(data->verdict);
+	desc->type = NFT_DATA_VERDICT; // Code needs to be added after patch reverse
 
 	return 0;
 }
@@ -9036,14 +9051,20 @@ static int nft_value_init(const struct nft_ctx *ctx,
 		return -EINVAL;
 	if (len > desc->size)
 		return -EOVERFLOW;
-	if (desc->len) {
-		if (len != desc->len)
-			return -EINVAL;
-	} else {
-		desc->len = len;
-	}
+	// if (desc->len) {
+	// 	if (len != desc->len)
+	// 		return -EINVAL;
+	// } else {
+	// 	desc->len = len;
+	// }
 
 	nla_memcpy(data->data, nla, len);
+	/*
+	Codes below need to be added after patch reverse
+    */
+    desc->type = NFT_DATA_VALUE;
+    desc->len = len;
+    
 
 	return 0;
 }
@@ -9079,8 +9100,8 @@ int nft_data_init(const struct nft_ctx *ctx, struct nft_data *data,
 	struct nlattr *tb[NFTA_DATA_MAX + 1];
 	int err;
 
-	if (WARN_ON_ONCE(!desc->size))
-		return -EINVAL;
+	// if (WARN_ON_ONCE(!desc->size))
+	// 	return -EINVAL;
 
 	err = nla_parse_nested_deprecated(tb, NFTA_DATA_MAX, nla,
 					  nft_data_policy, NULL);
@@ -9088,18 +9109,19 @@ int nft_data_init(const struct nft_ctx *ctx, struct nft_data *data,
 		return err;
 
 	if (tb[NFTA_DATA_VALUE]) {
-		if (desc->type != NFT_DATA_VALUE)
-			return -EINVAL;
+		// if (desc->type != NFT_DATA_VALUE)
+		// 	return -EINVAL;
 
 		err = nft_value_init(ctx, data, desc, tb[NFTA_DATA_VALUE]);
 	} else if (tb[NFTA_DATA_VERDICT] && ctx != NULL) {
-		if (desc->type != NFT_DATA_VERDICT)
-			return -EINVAL;
+		// if (desc->type != NFT_DATA_VERDICT)
+		// 	return -EINVAL;
 
 		err = nft_verdict_init(ctx, data, desc, tb[NFTA_DATA_VERDICT]);
-	} else {
-		err = -EINVAL;
-	}
+	} 
+	// else {
+	// 	err = -EINVAL;
+	// }
 
 	return err;
 }
